首先介绍一篇比较好的介绍立体匹配的综述性文章：http://wenku.baidu.com/view/5b359d7d5acfa1c7aa00cc7b.html

而后有一个较好的介绍立体匹配的PPT：http://wenku.baidu.com/view/cabedc4bc850ad02de804124.html

下面的内容转载自：http://www.360doc.com/content/12/0621/19/10004630_219681094.shtml，具体介绍了立体匹配十个方面的概念：

一、概念

        立体匹配算法主要是通过建立一个能量代价函数，通过此能量代价函数最小化来估计像素点视差值。立体匹配算法的实质就是一个最优化求解问题，通过建立合理的能量函数，增加一些约束，采用最优化理论的方法进行方程求解，这也是所有的病态问题求解方法。

二、主要立体匹配算法分类

1）根据采用图像表示的基元不同，立体匹配算法分为：

       A、区域立体匹配算法（可获取稠密视差图。缺点：受图像的仿射畸变和辐射畸变影响较大；像素点约束窗口的大小与形状选择比较困难，选择过大，在深度不连续处，视差图中会出现过度平滑现象；选择过小，对像素点的约束比较少，图像信息没有得到充分利用，容易产生误匹配。）

       B、基于特征的立体匹配算法（可获得稀疏的视差图，经差值估计可获得稠密视差图。可提取点、线、面等局部特征，也可提取多边形和图像结构等全局特征。缺点：特征提取易受遮挡、光线、重复纹理等影响较大；差值估计计算量大）

       C、基于相位立体匹配算法（假定在图像对应点中，其频率范围内，其局部相位是相等的，在频率范围内进行视差估计）

2）依据采用最优化理论方法的不同，立体匹配算法可以分为：

       A、局部的立体匹配算法

       B、全局的立体匹配算法

三、匹配基元（match primitive）

目前匹配算法中所采用的匹配基元可以分成两大类：

1）在所有图象像素点上抽取量测描述子

      A、像素灰度值（最简单、直接，但必须在同一光照条件下获得）

      B、局部区域灰度函数（主要是利用求得在各种大小不同窗口中灰度分布的导数信息，描述像素点周围的结构矢量。）

      C、卷积图象符号（利用各种大小算子与图象进行卷积，用灰度梯度局部极大值或极小值作为特征信息，描述整个图像）

2）图像特征

      A、过零点

      B、边缘（由于边缘是图像特征位置的标志，对灰度值的变化不敏感，边缘是图像匹配的重要特征和描述子）

      C、角点（虽然其没有明确的数学定义，但大家普遍认为角点，即二维图像亮度变化剧烈的点或边缘曲线上曲率极值点）

四、区域匹配算法

        基本原理是给定在一幅图像上的某一点，选取该像素点邻域内的一个子窗口，在另一幅图像中的一个区域内，根据某种相似性判断依据，寻找与子窗口图像最为相似的子图，而其匹配的子图中对应的像素点就为该像素的匹配点。

        一般单纯的区域匹配都遇到如下限制：

       1）针对弱纹理或存在重复纹理的区域，匹配结果不好

       2）该算法不适应于深度变化剧烈的场景

       3）对光照、对比度和噪声比较敏感

       4）子窗体的大小很难选择

五、特征匹配算法

        特征的匹配算法，主要是基于几何特征信息（边缘、线、轮廓、兴趣点、角点和几何基元等），针对几何特征点进行视差估计，所以先要提取图像的特征点，尽而利用这些特征点的视差值信息来重建三维空间场景。

        匹配所需要的主要步骤：图像预处理、提取特征、特征点的匹配获取稀疏视差图，如果想得到稠密的视差图，需要采用插值的方法。

六、全局匹配算法

        全局立体匹配算法主要是采用了全局的优化理论方法估计视差，建立全局能量函数，通过最小化全局能量函数得到最优视差值。

        全局匹配算法得到的结果比较准确，但是其运行时间比较长，不适合实时运行。主要的算法有图割（graph cuts）、信念传播（belief propagation）、动态规划等算法。

七、局部匹配算法（个人觉得跟区域匹配类似，角度不同而已）

        主要是采用局部优化方法进行视差值估计，局部立体匹配算法有 SAD，SSD 等算法，与全局立体匹配算法一样，也是通过能量最小化方法进行视差估计，但是，在能量函数中，只有数据项，而没有平滑项。

       主要分为三类：自适应窗体立体匹配算法、自适应权值的立体匹配算法和多窗体立体匹配算法。

八、立体匹配约束

1）极线约束

2）唯一性约束

3）视差连续性约束

4）顺序一致性约束

5）相似性约束

九、相似性判断标准

1）像素点灰度差的平方和，即 SSD

2）像素点灰度差的绝对值和，即 SAD

3）归一化交叉相关，简称 NCC

4） 零均值交叉相关，即 ZNCC

5）Moravec 非归一化交叉相关，即 MNCC

6） Kolmogorov-Smirnov 距离，即 KSD

7）Jeffrey 散度

8）Rank 变换（是以窗口内灰度值小于中心像素灰度值的像素个数来代替中心像素的灰度值）

9）Census 变换（是根据窗口内中心像素灰度与其余像素灰度值的大小关系得一串位码，位码长度等于窗口内像素个数减一）

十、评价参数

        立体匹配算法是一个病态问题，一般通过建立能量函数，利用最小化能量函数，和一些约束条件，采用最优化理论方法进行求解方程。

        公认的定量评价参数有：均方根误差(Root-mean-squared)和误匹配率(percentage of bad matching pixels)

  

     其中，利用极线约束、唯一性约束、顺序性约束以及特征约束的方法较为常用。对于场景连续变化，缩放、光照以及旋转变化不大的场景来说，模板匹配算法（SSD、SAD等）配合极线和特征约束可以实现快速得到稠密匹配的目的。同时为了加速可以考虑利用改进的模板匹配算法以及GPU加速。



  A、匹配代价计算
  匹配代价计算是整个立体匹配算法的基础，实际是对不同视差下进行灰度相似性测量。
  常见的方法有灰度差的平方SD（squared intensity differences），灰度差的绝对值AD（absolute intensity differences）等。
  另外，在求原始匹配代价时可以设定一个上限值，来减弱叠加过程中的误匹配的影响。

  B、匹配代价叠加
  全局算法基于原始匹配代价进行后续算法计算。而区域算法则需要通过窗口叠加来增强匹配代价的可靠性，根据原始匹配代价不同，可分为：
  - SSD(sum of squared differences)
  - SAD(sum of absolute dofferemces)
  - NCC(normalized cross - correlation)

  C. 视差获取
  对于区域算法来说，在完成匹配代价的叠加以后，视差的获取就很容易了，只需在一定范围内选取叠加匹配代价最优的点
  （SAD和SSD取最小值，NCC取最大值）作为对应匹配点，如胜者为王算法WTA（Winner-take-all）。
  而全局算法则直接对原始匹配代价进行处理，一般会先给出一个能量评价函数，然后通过不同的优化算法来求得能量的最小值，同时每个点的视差值也就计算出来了。
	
  D、视差细化（亚像素级）
  大多数立体匹配算法计算出来的视差都是一些离散的特定整数值，可满足一般应用的精度要求。
  但在一些精度要求比较高的场合，如精确的三维重构中，就需要在初始视差获取后采用一些措施对视差进行细化，如匹配代价的曲线拟合、图像滤波、图像分割等。
  亚像素级的处理就是涉及到BMState参数设置后后续参数的设置了。