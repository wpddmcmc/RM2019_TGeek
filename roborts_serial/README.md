# roborts_base
先运行`robort_bringup`下的`create_udev_rules.sh`即可生成USB接口映射规则, 大疆STM32主控板对应`"/dev/serial_sdk"`, 串口模块对应`"dev/robomaster"`。

## 一、协议
### 机器人串口通信接收
```c++
uint8_t sof;                  // 帧头 = 0A
uint8_t robot_id;             // 机器人id
uint8_t cmd_mode;             // 命令模式，0 空闲 1 自瞄 2 打符 ...
int16_t yaw_angle;            // 单位：角度 x 1000
int16_t pitch_angle;          // 单位：角度 x 1000
int16_t yaw_rate;             // 单位：度/秒 x 1000
int16_t pitch_rate;           // 单位：度/秒 x 1000
uint8_t end;                  // 帧尾 = B0
```

1. 机器人id与裁判系统的规定方式相同。
2. 命令模式用于手自一体, 建议对应操作手键位用于视觉任务的切换。
3. 建立坐标系, yaw角度向右为正, pitch角度向上为正; 速度同理。

### 机器人串口通信发送
```c++
uint8_t sof;                  // 帧头 = 0C
uint8_t task_id;              // 任务id（用户自定义）
uint8_t vision_data_status;   // 数据状态（用户自定义）
int16_t vision_data_x;        // 单位: mm
int16_t vision_data_y;        // 单位: mm
int16_t vision_data_z;        // 单位: mm
uint8_t cmd_mode;             // 控制模式，1 绝对角度 2 相对角度 3 绝对速度 4 相对速度
int16_t cmd_gimbal_yaw;       // 云台控制，单位同接收
int16_t cmd_gimbal_pitch;     // 云台控制，单位同接收
uint8_t end;                  // 帧尾 = D0
```

1. `task_id`是执行何种任务。
2. `vision_data_status`是标志位，需要与`task_id`组合使用， `xyz` 是坐标，电控可以用来作额外数据检查。
3. 极简模式下，仅仅依据 `cmd_gimbal_yaw`和`cmd_gimbal_pitch`就可以实现控制。 
4. xyz的坐标定义, x向右为正, y向上为正, z向前为正。

#### task_id任务表

| task_id | cmd_mode = 0 | cmd_mode = 1 or 2 | 
|:--------|:-------------|:------------------|
|    0    |      无效    |        待命        |
|    1    |      无效    |      瞄准跟随      |
|    2    |      无效    |        点射        |
|    3    |      无效    |       几连射       |
|    4    |      无效    |      连续射击      |
|   ...   |       ...   |         ...        | 

#### vision_data_status任务表
cmd_mode = 0，task_id无效，vision_data_status无效。

cmd_mode = 1

| status | task_id = 1 | task_id = 2 | task_id = 3 |task_id = 4     |
|:-------|:------------|:------------|:------------|:---------------|
|    0   |    无效     |     无效     |      无效   |    无效        |
|    1   |  跟随程度   |   点射1发    |均匀射频，1发/秒|极限射频，输出1秒| 
|    2   |  跟随程度   |   点射2发    |均匀射频，2发/秒|极限射频，输出2秒|
|    3   |  跟随程度   |   点秒3发    |均匀射频，3发/秒|极限射频，输出3秒|
|    4   |  跟随程度   |   点射4发    |均匀射频，4发/秒|极限射频，输出4秒|
|    5   |  跟随程度   |   点射5发    |均匀射频，5发/秒|极限射频，输出5秒|

cmd_mode = 2

|     | vision_data_status |
|:----|:-------------------|
|  0  |   当前打符进度0/5   |
|  1  |   当前打符进度1/5   |
|  2  |   当前打符进度2/5   |
|  3  |   当前打符进度3/5   |
|  4  |   当前打符进度4/5   |
|  5  |   当前打符进度5/5   |

**Note:**
1. cmd_mode = 1 , task_id = 4, vision_data_status输出状态可以被打断。
2. 视觉要把电控视作不会思考的下位机，所有的调参集中于视觉，对方是步兵还是英雄，是猫步还是陀螺，决策逻辑都是视觉内部完成，到达串口传输时，就只是单纯的命令。
3. 点射用于精准打击，连射用于火力压制，这些调参都由视觉完成，如果两边同时调参，效果很玄学。
4. 手自一体的机器人也适用于这一协议，操作手点一下鼠标，会触发电控接收数据，而发射模式是由视觉决定的，比如触发自瞄后，按鼠标左键可能会3连发，哒哒哒~。
5. 以上如果电控不靠谱，尤其是英雄，可以屏蔽这些数据，只接收`cmd_gimbal_yaw`和`cmd_gimbal_pitch`。

## 二、原理
单ROS节点，双线程以固定频率强制发送与接受；该ROS节点不定时接收其他节点的数据，然后只负责更新数据。

`/sdk`下面是串口底层实现，为了代码解耦、模块化、不要往里面加协议相关的东西，更不要加其他奇奇怪怪的东西。

`/serial`是串口协议的实现部分，这里大部分都是人为规定，单位、方向、角度、乘1000、除以1000、等等。今后会更加严格的统一。

云台控制中的速度值得一试，根据电控PID，我们直接发PID的输入量或许会好很多。

所有机器人都使用同一份串口协议。目前，数据发送与数据更新的部分可能需要加锁。